---
title: "Study Guide - Week 1"
categories:
  - study-guides
tags:
  - week-1
---

> "You've been here before"  
> \- Stephen King, "Needful Things"

# Welcome friend

This is an on-going series meant to be an accompanying guide throughout your journey in _this module_.

**Disclaimer: this is not an official resource!**

# Introduction

This module requires you to make up for any shortages in knowledge and experience in an extremely short period of time.
It has also seen a huge revamp in coursework over the summer.
Major changes include a whole new individual project and framework for the team project.
Discard any stories you've heard from your friends who has taken this module before.   

Engage with your prof/tutors and course mates.
Clarify your doubts on the official forum.

> 聞くは一時の恥、聞かぬは一生の恥
> 
> "Asking is but a moment of shame, not knowing is a lifetime of shame" - Japanese proverb 

This module has a radically different classroom structure in which most of the work is done _outside_ of lectures and tutorials.
You are expected to do all the tutorials and be confident enough to not only present, but to teach the material.
Teaching requires a deeper level of understanding so it's a better gauge of what you _don't_ know. 
Since tutorial time is _really_ short, be on time and be ready to go. 

Obviously, this means that you are required to do all of your work beforehand. 
This module has been taught for a very long time and I can assure you that every exercise is there because it is important.
Do all of them and keep the answers somewhere.
You will be needing them for finals and none will be provided.

You are strongly recommended to read through the whole textbook once while you still can. 
Don't worry about memorizing every single piece of information, you just need to get a rough feel of what's in there.
Again, this is because the module covers a lot of ground.
For example, not knowing more advanced OOP concepts will result in you writing nigh untestable code since the chapters on OOP concepts and testing do not appear until fairly late.

For ~~grade-oriented~~ students, **READ THE GRADING SCHEME**.
**NO REALLY, I CANNOT STRESS THIS ENOUGH. READ. THE. GRADING. SCHEME.** 
Understand early that this module is not just about coding skills. 
Documentation, tests and an eye for detail will make or break your project and in turn, your grade.
The implications of a lack of bell curve for the project portion of the module should be evident.

# Task breakdown for the week
 
## IDE Setup 

It is recommended that you use IntelliJ IDEA. Use it.

Make full use of your student status and apply for a free Ultimate license.
Takes all of 5 minutes and you'll be using it for a long, long time to come.

> "B-b-but what about {insert electron-based editor here}"

No. If you're going to eat 1GB of RAM to render a blinking cursor in chrome you might as well feed it to IntelliJ.

It is known that most developers do not configure more "advanced settings". 
Please do not be _most developers_. 
Open the correct `.vmoptions` and feed IntelliJ more memory.

I'll even do you a solid and link the official docs on [how to do that](https://www.jetbrains.com/help/idea/tuning-the-ide.html). 

Aggressively disable plugins that you won't be needing.
If you have read ahead (as you should), you will know that the following plugins will be used later:

- Checkstyle
- PlantUML
- AsciiDoc

Might as well get a head start and get it out of the way. 

## GitHub

If you finished the pre-module survey, this should not be an issue. 

## Git 

### Setting up
Perform some global configs first. 

Set your `user.name` to reflect what you provided to the module. 
If you're using multiple computers, make sure that it is consistent across all of them.
This will save you a lot of heartache near the end of the module.

I personally love to trick out my `.gitconfig` to something more comfortable.
Set `core.editor` to something that you like (and can configure to insert line-break).

```editorconfig
[log]
  date = relative
[format]
  pretty = format:%C(yellow)%h %Cblue%>(12)%ad %Cgreen%<(7)%aN%Cred%d %Creset%s
```
Copy-pasting the block above into your `.gitconfig` will turn your `git log` into something actually useful.
Muck around with it to get the exact experience you want to have.

### Learning `git`

Please learn how to use `git` without installing `{electron-based-tool-x}`.
Nothing comes close to the raw power that console git allows you.
Trust me on this one.

For some of you, this will be the first time you're using `git` in a team setting. 
It can be extremely intimidating, especially when you start reading something like [Pro Git](https://git-scm.com/book/en/v2).
(It's a great book, and you should definitely read it.) 
My advice would be to get used to basic `git` stuff while you are still working on your individual project. 

Some practical stuff to try:
1. Practice the branch and merge workflow instead of committing to `master`.

    Later on when you will working in teams of 5, having 4 other people consistently force-pushing to master will make you feel emotions you have never felt before.
    Learn basic `git` hygiene now and hope the rest of your team does the same.
    
1. Make small, focused commits and make them often.

    You **are** going to mess up. 
    We all do.
    Small, focused commits allow you to rearrange/revert relevant commits and allow you and your team to work around all of life's mistakes.
    
1. Learn about `git rebase`, seriously.

    `git rebase -i (...)` saves lives. 
 
There's almost always more than one way to get things done with `git`.
The more `git` you know, the more elegant and simple your solution will be.
Remember, the more `git` you know, the more `git` you use. 

# Extra material
 
## OOP concepts

### Utility classes

For the purposes of this discussion, classes which only define `public static` method or expose constants are considered to be utility classes.

It is often argued by OOP purists that utility classes are a code smell. 
The argument is that we should model objects and compose them. 

Consider this contrived example 

```java
//
public static class AdvancedMath {
    public static int superHardAddition(int a, int b) { return a + b; }
}

//...
// Let's use our new static method. 
int result = AdvancedMath.superHardAddition(400, 20);
// Cool.
```

vs 

```java
public class LimitedEditionSupremeNumberAdder{
    private int a;
    private int b;
    public LimitedEditionSupremeNumberAdder(int a, int b) {
        this.a = a;
        this.b = b;
    }
    public int getSum() { return a + b;}
}

//...
// OOP way 
int result = new LimitedEditionSupremeNumberAdder(60, 9).getSum();
// Nioe.
```

The latter example has some advantages:

1. It does one obvious thing and only one thing.
1. It's relatively small.
1. It's easily testable.
1. Chaining calls with it fails fast and early.

You will learn some formal terms to describe these properties later on.

However, these does not mean that the former approach is bad.
In fact, the standard Java library has quite a few of them that you will be encountering soon enough.

Advantages include:

1. A smaller memory footprint.
1. Reduces coupling.

If done right, utility classes can still add a lot of value to the design of your application!

The important takeaway is to know that small design choices can be highly impactful.
Make conscious decisions that you can defend.  

### Functional concepts in an OOP world

Just because Java is an OOP language doesn't mean that you can't benefit from some functional teachings.
Without getting too deep into funky functional stuff like zygomorphic prepromorphism, let's review some basic tenets of functional programming.

#### Emphasis on immutability

Mutability invariably leads to unpredictability. 
Less mutable stuff, less unpredictable behavior. 

Consider the following example: 

```java
class ImmutableProperty<T> {
    T a, b;
    public ImmutableProperty(T a, T b) {
        this.a = a;
        this.b = b;
    }
    
    public ImmutableProperty<T> withA(T newA) {
        return new ImmutableProperty<T>(newA, b);
    }
    
    public ImmutableProperty<T> withB(T newB) {
            return new ImmutableProperty<T>(a, newB);
    }

    public T getA() { return a; }
    public T getB() { return b; }
    
}

// ... 
// Usage
var notNice = new ImmutableProperty<Integer>(0, 0);
var veryNice = notNice.withA(420).withB(69);
```

There are no setters for the class because there is simply nothing to mutate. 
Working with the class is fairly pleasant as you are guaranteed that passing any instance of `ImmutableProperty<T>` into an external, unfriendly method is bound to not mutate it.

Compare that to this wild ride.

```java
class MutableProperty<T> {
    public T a, b;
    public MutableProperty(T a, T b) {
        this.a = a;
        this.b = b;
    }
}

// ... 
// Usage
var myFavoriteNumbers = new MutableProperty<Integer>(1337, 369);

public void noCountryForOldMen(MutableProperty<Integer> mp) {
    System.out.println(mp.a.toString() + " " + mp.b.toString());
    //would you hold still please, sir?
    mp.a =  mp.b = 0;
}

noCountryForOldMen(myFavoriteNumbers);

myFavoriteNumbers.a; // 0
myFavoriteNumbers.b; // 0
``` 

While not every method is out there to get you, reducing the surface area where things can go wrong is always good.
Also, the example above can be slightly hardened by changing `public T a ,b;` to `private T a, b;` and implementing getters and setters (a.k.a accessors and mutators).
However, this still does not change the fact that external methods can make unwanted changes.

Also, the external mutator method `noCountryForOldMen()` violates many other principles, but you will learn about those later on.

#### Minimizing side effects

This follows nicely from the previous point. 
Methods are expected to have no side effects.
Essentially this just means that:
1. running the same method with the same arguments will always produce the same result
1. a call to the method can always be replaced by its return value  

Consider the following: 

```java
public void printTime() {
    System.out.println(new Date());
}

public void printTime(Date d) {
    System.out.println(d);
}

public String getTimeString(Date d) {
    return d.toString();
}
```

The first method has side effects : running the same method repeatedly will print a different date.

The second method has side effects as well : the output stream is modified from the `println` and you cannot replace a call to `printTime(Date)` with its return value.

The third method is has no side effects.

The functional paradigm aims to minimize the amount of code with side-effects by postponing side-effects for as long as possible.
This results in a functional core and a thin layer of non-functional code. 

#### Applying functional concepts in Java 
If you read ahead to the code base of addressbook level 3+, you will find that there is a design decision made to avoid mutables as much as possible.
The `Person` class exposes no properties nor mutators.
For example, if you need to edit a `Person`, you have to create an `EditPersonDescriptor` which is then used generate a new `Person` with the updated properties.


### Exceptions 

>```go
>if err != nil { }
>```
> \- Every `go` program, ad nauseam

Since Java actually has some sort of error handling, use it.
Be aware of everything that can go wrong in your program and account for them. 

In general, catch-alls like `Exception e` are an obvious code smell and most static analysis programs will warn you about them.
Never, ever resort to using exceptions as control flow. 

If you can't understand why that's an exceptionally bad idea:

1. Normalisation of the abnormal
    
    Exceptions are meant to highlight abnormalities.
    If you use them willy-nilly, it will become harder to find actual errors.

1. Locality

    Fail to catch one and it goes up the stack searching for a handler.
    This results code not failing in the right place and tracking down the source of the bug way harder. 

1. Performance

    This should be the least of your worries but a worry nonetheless. 

### Errors 
Errors are the non-negotiable versions of Exceptions. You don't catch them, you don't handle them. Your program just gives up the ghost and terminates.
